
=======================
ðŸ“˜ EXAMEN TME - ROBOT 2D/3D
=======================

PARTIE 1 - COMPRÃ‰HENSION GÃ‰NÃ‰RALE
---------------------------------

1. Que fait exactement main2d.py au lancement ?
> Il initialise lâ€™environnement 2D, le robot simulÃ©, lâ€™adaptateur, le contrÃ´leur et lâ€™interface graphique 2D.

2. Que fait main3d.py ?
> Il fait la mÃªme chose que main2d.py mais pour la version 3D avec une interface diffÃ©rente.

3. Quelle est la diffÃ©rence entre RobotSimule et RobotReel ?
> RobotSimule agit dans une simulation, RobotReel interagit avec un vrai robot physique.

4. Câ€™est quoi un adaptateur ?
> Un adaptateur est un traducteur entre le contrÃ´leur et le robot (rÃ©el ou simulÃ©), pour rendre les commandes compatibles.

5. Ã€ quoi sert lâ€™interface graphique ?
> Elle permet de visualiser lâ€™environnement, les obstacles, les mouvements du robot et dâ€™interagir avec.

6. Ã€ quoi sert le contrÃ´leur ?
> Ã€ exÃ©cuter les stratÃ©gies de dÃ©placement du robot en utilisant lâ€™adaptateur.

7. OÃ¹ sont dÃ©finies les stratÃ©gies ?
> Dans le fichier src/controleur/strategies.py

8. Que fait la mÃ©thode step() dans une stratÃ©gie ?
> Elle est appelÃ©e en boucle pour mettre Ã  jour lâ€™action du robot (avancer, tourner, sâ€™arrÃªter, etc.).

9. Comment lâ€™environnement connaÃ®t la position du robot ?
> GrÃ¢ce Ã  la mÃ©thode environnement.setRobot(adaptateur)

10. Pourquoi on a plusieurs adaptateurs ?
> Pour gÃ©rer diffÃ©rents types de robot (simulÃ©, rÃ©el, test/mockup) sans modifier les stratÃ©gies.

PARTIE 2 - MODIFICATION DEMANDÃ‰E
--------------------------------

11. Comment dÃ©sactiver lâ€™affichage graphique ?
> Commenter :
   - l'import dâ€™Affichage
   - la crÃ©ation de lâ€™affichage
   - affichage.mettre_a_jour()
   - affichage.attendre_fermeture()
   - remplacer la boucle graphique par une boucle manuelle de stratÃ©gie.

12. Comment changer la couleur du robot ?
> En passant le paramÃ¨tre couleur lors de lâ€™instanciation : RobotSimule(..., couleur="red")

13. Comment changer la vitesse du robot ?
> Modifier VIT_ANG_AVAN dans utils.py ou passer une nouvelle valeur dans setVitAngA(vitesse)

14. OÃ¹ se trouvent les constantes de vitesse ?
> Dans src/utils.py

15. Que faire pour ajouter un obstacle ?
> Utiliser env.addObstacle("type", liste_de_points)

16. Comment crÃ©er une nouvelle stratÃ©gie ?
> CrÃ©er une nouvelle classe dans strategies.py avec start(), step(), stop() et lâ€™ajouter dans set_strategie() du Controler.

17. Comment faire avancer un robot sans interface graphique ?
> Appeler start(), step() dans une boucle puis stop() sur la stratÃ©gie.

PARTIE 3 - STRUCTURE DU CODE
----------------------------

18. Pourquoi utiliser des constantes comme VIT_ANG_AVAN ?
> Pour Ã©viter les valeurs magiques et centraliser les paramÃ¨tres.

19. Pourquoi sÃ©parer le robot du contrÃ´leur ?
> Pour rendre le code modulaire et pouvoir tester ou changer de robot facilement.

20. Quel est le rÃ´le du fichier adapt_simule.py ?
> Adapter les commandes du contrÃ´leur pour le robot simulÃ©.

21. Quelle est la relation entre le contrÃ´leur, lâ€™adaptateur et la stratÃ©gie ?
> Le contrÃ´leur choisit et exÃ©cute une stratÃ©gie qui envoie des ordres Ã  travers lâ€™adaptateur.

22. Pourquoi utilise-t-on Thread dans Controler ?
> Pour que la stratÃ©gie sâ€™exÃ©cute en parallÃ¨le sans bloquer lâ€™affichage.

23. Quelle mÃ©thode utilise-t-on pour faire tourner le robot ?
> setVitAngGA(vitesse) ou setVitAngDA(vitesse)

24. Quelles mÃ©thodes contrÃ´lent les roues du robot ?
> set_VitG(v), set_VitD(v) dans RobotSimule.

25. Comment dÃ©tecter un obstacle dans une stratÃ©gie ?
> En utilisant adaptateur.getDistanceObstacle()

